import React, { useMemo, useState } from 'react'
import {
  Paper,
  Stack,
  Typography,
  Box,
  Grid,
  Card,
  CardContent,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  Button,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Checkbox,
  List,
  ListItem,
  ListItemIcon,
  ListItemText,
  ListItemButton,
  Chip,
  Badge,
  TextField,
} from '@mui/material'
import { BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer, Cell } from 'recharts'
import { useTranslation } from 'react-i18next'
import { useOperations } from '../hooks/useOperations'
import { useCategories } from '../hooks/useCategories'
import { useAccountsData } from '../hooks/useAccountsData'
import { useHashtags } from '../hooks/useHashtags'

interface FilterState {
  period: 'currentMonth' | 'lastMonth' | 'lastQuarter' | 'lastYear' | 'custom'
  customDateFrom: string
  customDateTo: string
  selectedAccounts: number[]
  selectedCategories: number[]
  selectedHashtags: number[]
}

interface ComparisonPeriod {
  key: 'lastMonth' | 'lastQuarter' | 'lastYear'
  label: string
  income: number
  expense: number
  balance: number
}

const Statistics: React.FC = () => {
  const { t } = useTranslation()
  const { operationsQuery } = useOperations()
  const { categoriesQuery } = useCategories()
  const { accountsQuery } = useAccountsData()
  const { hashtags } = useHashtags()

  const operations = operationsQuery.data ?? []
  const categories = categoriesQuery.data ?? []
  const accounts = accountsQuery.data ?? []

  const activeAccountIds = accounts.filter(a => !a.is_closed).map(a => a.id)

  // Filter state
  const [filters, setFilters] = useState<FilterState>({
    period: 'currentMonth',
    customDateFrom: '',
    customDateTo: '',
    selectedAccounts: activeAccountIds,
    selectedCategories: [],
    selectedHashtags: [],
  })

  // Modal state
  const [filterModalOpen, setFilterModalOpen] = useState(false)
  const [comparisonEnabled, setComparisonEnabled] = useState(false)

  // Helper function to get date range based on period
  const getDateRange = (period: string, customFrom?: string, customTo?: string) => {
    const now = new Date()
    let startDate: Date, endDate: Date

    switch (period) {
      case 'currentMonth':
        startDate = new Date(now.getFullYear(), now.getMonth(), 1)
        endDate = new Date(now.getFullYear(), now.getMonth() + 1, 0, 23, 59, 59)
        break
      case 'lastMonth':
        startDate = new Date(now.getFullYear(), now.getMonth() - 1, 1)
        endDate = new Date(now.getFullYear(), now.getMonth(), 0, 23, 59, 59)
        break
      case 'lastQuarter':
        const quarterStart = Math.floor((now.getMonth() - 3) / 3) * 3
        startDate = new Date(now.getFullYear(), quarterStart, 1)
        endDate = new Date(now.getFullYear(), quarterStart + 3, 0, 23, 59, 59)
        break
      case 'lastYear':
        startDate = new Date(now.getFullYear() - 1, 0, 1)
        endDate = new Date(now.getFullYear() - 1, 11, 31, 23, 59, 59)
        break
      case 'custom':
        startDate = customFrom ? new Date(customFrom) : new Date()
        endDate = customTo ? new Date(customTo) : new Date()
        break
      default:
        startDate = new Date(0)
        endDate = new Date()
    }

    return { startDate, endDate }
  }

  // Helper to filter operations by all criteria including hashtags
  const filterOperations = (ops: typeof operations, filterState: FilterState) => {
    const { startDate, endDate } = getDateRange(
      filterState.period,
      filterState.customDateFrom,
      filterState.customDateTo
    )

    return ops.filter(o => {
      const opDate = new Date(o.operation_date)
      const inRange = opDate >= startDate && opDate <= endDate
      const accountMatch =
        filterState.selectedAccounts.length === 0 || filterState.selectedAccounts.includes(o.account_id)
      const categoryMatch =
        filterState.selectedCategories.length === 0 || 
        (o.category_id && filterState.selectedCategories.includes(o.category_id))
      const hashtagMatch =
        filterState.selectedHashtags.length === 0 ||
        (o.hashtags && o.hashtags.some(h => filterState.selectedHashtags.includes(h.id)))

      return inRange && accountMatch && categoryMatch && hashtagMatch
    })
  }

  // Statystyki og√≥lne (wszystkie konta, wszystkie okresy)
  const overallStats = useMemo(() => {
    const totalIncome = operations
      .filter(o => o.operation_type === 'income')
      .reduce((sum, o) => sum + o.amount, 0)

    const totalExpense = operations
      .filter(o => o.operation_type === 'expense')
      .reduce((sum, o) => sum + o.amount, 0)

    return {
      totalIncome,
      totalExpense,
      netBalance: totalIncome - totalExpense,
    }
  }, [operations])

  // Statystyki filtrowane
  const filteredStats = useMemo(() => {
    const { startDate, endDate } = getDateRange(
      filters.period,
      filters.customDateFrom,
      filters.customDateTo
    )

    const filtered = filterOperations(operations, filters)

    const income = filtered
      .filter(o => o.operation_type === 'income')
      .reduce((sum, o) => sum + o.amount, 0)

    const expense = filtered
      .filter(o => o.operation_type === 'expense')
      .reduce((sum, o) => sum + o.amount, 0)

    return {
      income,
      expense,
      balance: income - expense,
      periodStart: startDate.toLocaleDateString(),
      periodEnd: endDate.toLocaleDateString(),
    }
  }, [operations, filters])

  // Comparison data for 3 periods
  const comparisonStats = useMemo(() => {
    const result: ComparisonPeriod[] = []

    const periods: Array<'lastMonth' | 'lastQuarter' | 'lastYear'> = ['lastMonth', 'lastQuarter', 'lastYear']
    const labels = {
      lastMonth: t('statistics.period.lastMonth') ?? 'Last Month',
      lastQuarter: t('statistics.period.lastQuarter') ?? 'Last Quarter',
      lastYear: t('statistics.period.lastYear') ?? 'Last Year',
    }

    periods.forEach(period => {
      const { startDate, endDate } = getDateRange(period)
      
      const filtered = operations.filter(o => {
        const opDate = new Date(o.operation_date)
        const inRange = opDate >= startDate && opDate <= endDate
        const accountMatch =
          filters.selectedAccounts.length === 0 || filters.selectedAccounts.includes(o.account_id)
        const categoryMatch =
          filters.selectedCategories.length === 0 || 
          (o.category_id && filters.selectedCategories.includes(o.category_id))
        const hashtagMatch =
          filters.selectedHashtags.length === 0 ||
          (o.hashtags && o.hashtags.some(h => filters.selectedHashtags.includes(h.id)))

        return inRange && accountMatch && categoryMatch && hashtagMatch
      })

      const income = filtered
        .filter(o => o.operation_type === 'income')
        .reduce((sum, o) => sum + o.amount, 0)

      const expense = filtered
        .filter(o => o.operation_type === 'expense')
        .reduce((sum, o) => sum + o.amount, 0)

      result.push({
        key: period,
        label: labels[period],
        income,
        expense,
        balance: income - expense,
      })
    })

    return result
  }, [operations, filters, t])

  // Statystyki po kategoriach dla wykresu
  const chartData = useMemo(() => {
    const categoryExpenses: { [key: number]: { name: string; amount: number } } = {}

    const filtered = filterOperations(operations, filters)

    filtered
      .filter(o => o.operation_type === 'expense' && o.category_id)
      .forEach(o => {
        if (o.category_id) {
          if (!categoryExpenses[o.category_id]) {
            const cat = categories.find(c => c.id === o.category_id)
            const parentCat = cat?.parent_id ? categories.find(c => c.id === cat.parent_id) : null
            categoryExpenses[o.category_id] = {
              name: parentCat ? `${parentCat.name} ‚Üí ${cat?.name}` : cat?.name || 'Unknown',
              amount: 0,
            }
          }
          categoryExpenses[o.category_id].amount += o.amount
        }
      })

    return Object.values(categoryExpenses)
      .sort((a, b) => b.amount - a.amount)
      .map(cat => ({
        name: cat.name.length > 20 ? cat.name.substring(0, 20) + '...' : cat.name,
        value: cat.amount,
        fullName: cat.name,
      }))
  }, [operations, categories, filters])

  const COLORS = ['#ff7c7c', '#8884d8', '#82ca9d', '#ffc658', '#ff85a2', '#a4de6c', '#d084d0', '#ffb347', '#87ceeb', '#f0e68c']

  const subcategories = categories.filter(c => c.parent_id !== null).sort((a, b) => a.name.localeCompare(b.name))

  // Count active filters
  const activeFiltersCount = useMemo(() => {
    let count = 0
    if (filters.selectedAccounts.length < activeAccountIds.length) count++
    if (filters.selectedCategories.length > 0) count++
    if (filters.selectedHashtags.length > 0) count++
    if (filters.period === 'custom') count++
    return count
  }, [filters, activeAccountIds])

  return (
    <Box sx={{ display: 'flex', flexDirection: 'column', gap: 3 }}>
      {/* G√≥rny panel - sumaryczne warto≈õci na wszystkich kontach */}
      <Grid container spacing={2}>
        <Grid item xs={12} sm={6} md={3}>
          <Card>
            <CardContent>
              <Typography color="textSecondary" gutterBottom>
                {t('operations.summary.totalIncome') ?? 'Total Income'}
              </Typography>
              <Typography variant="h5" sx={{ color: '#4caf50' }}>
                {overallStats.totalIncome.toFixed(2)} z≈Ç
              </Typography>
            </CardContent>
          </Card>
        </Grid>

        <Grid item xs={12} sm={6} md={3}>
          <Card>
            <CardContent>
              <Typography color="textSecondary" gutterBottom>
                {t('operations.summary.totalExpense') ?? 'Total Expense'}
              </Typography>
              <Typography variant="h5" sx={{ color: '#f44336' }}>
                {overallStats.totalExpense.toFixed(2)} z≈Ç
              </Typography>
            </CardContent>
          </Card>
        </Grid>

        <Grid item xs={12} sm={6} md={3}>
          <Card>
            <CardContent>
              <Typography color="textSecondary" gutterBottom>
                {t('operations.summary.net') ?? 'Net Balance'}
              </Typography>
              <Typography variant="h5" sx={{ color: overallStats.netBalance >= 0 ? '#4caf50' : '#f44336' }}>
                {overallStats.netBalance.toFixed(2)} z≈Ç
              </Typography>
            </CardContent>
          </Card>
        </Grid>

        <Grid item xs={12} sm={6} md={3}>
          <Card>
            <CardContent>
              <Typography color="textSecondary" gutterBottom>
                Konta
              </Typography>
              <Typography variant="h5">
                {accounts.filter(a => !a.is_closed).length}
              </Typography>
              <Typography variant="caption" color="textSecondary">
                {t('statistics.activeAccounts') ?? 'Active'}
              </Typography>
            </CardContent>
          </Card>
        </Grid>
      </Grid>

      {/* Sekcja filtr√≥w */}
      <Paper sx={{ p: 3 }}>
        <Typography variant="h6" sx={{ mb: 2 }}>
          ÔøΩ {t('statistics.filters') ?? 'Filters'}
        </Typography>

        <Stack spacing={2}>
          {/* Okres */}
          <FormControl fullWidth sx={{ maxWidth: 300 }}>
            <InputLabel>{t('operations.dateFilter.label') ?? 'Period'}</InputLabel>
            <Select
              value={filters.period}
              onChange={e => setFilters({ ...filters, period: e.target.value as any })}
              label={t('operations.dateFilter.label') ?? 'Period'}
            >
              <MenuItem value="currentMonth">{t('statistics.period.currentMonth') ?? 'Current Month'}</MenuItem>
              <MenuItem value="lastMonth">{t('statistics.period.lastMonth') ?? 'Last Month'}</MenuItem>
              <MenuItem value="lastQuarter">{t('statistics.period.lastQuarter') ?? 'Last Quarter'}</MenuItem>
              <MenuItem value="lastYear">{t('statistics.period.lastYear') ?? 'Last Year'}</MenuItem>
              <MenuItem value="custom">{t('operations.dateFilter.custom') ?? 'Custom'}</MenuItem>
            </Select>
          </FormControl>

          {/* Custom dates */}
          {filters.period === 'custom' && (
            <Stack direction="row" spacing={2} sx={{ maxWidth: 600 }}>
              <TextField
                label={t('operations.dateFilter.from') ?? 'From'}
                type="date"
                value={filters.customDateFrom}
                onChange={e => setFilters({ ...filters, customDateFrom: e.target.value })}
                InputLabelProps={{ shrink: true }}
                sx={{ flex: 1 }}
              />
              <TextField
                label={t('operations.dateFilter.to') ?? 'To'}
                type="date"
                value={filters.customDateTo}
                onChange={e => setFilters({ ...filters, customDateTo: e.target.value })}
                InputLabelProps={{ shrink: true }}
                sx={{ flex: 1 }}
              />
            </Stack>
          )}

          {/* Konta - Autocomplete Multiselect */}
          <Autocomplete
            multiple
            options={activeAccountIds}
            value={filters.selectedAccounts}
            onChange={(_, value) => setFilters({ ...filters, selectedAccounts: value })}
            getOptionLabel={id => accounts.find(a => a.id === id)?.name || ''}
            renderInput={params => (
              <TextField
                {...params}
                label={t('operations.fields.account') ?? 'Accounts'}
                placeholder={t('statistics.selectAccounts') ?? 'Select accounts...'}
              />
            )}
            sx={{ maxWidth: 600 }}
          />

          {/* Kategorie - Autocomplete Multiselect */}
          <Autocomplete
            multiple
            options={subcategories.map(c => c.id)}
            value={filters.selectedCategories}
            onChange={(_, value) => setFilters({ ...filters, selectedCategories: value })}
            getOptionLabel={id => {
              const cat = categories.find(c => c.id === id)
              const parentCat = cat?.parent_id ? categories.find(c => c.id === cat.parent_id) : null
              return parentCat ? `${parentCat.name} ‚Üí ${cat?.name}` : cat?.name || ''
            }}
            renderInput={params => (
              <TextField
                {...params}
                label={t('operations.fields.category') ?? 'Categories'}
                placeholder={t('statistics.selectCategories') ?? 'Select categories...'}
              />
            )}
            sx={{ maxWidth: 600 }}
          />

          <Button
            variant="outlined"
            onClick={() => {
              setFilters({
                period: 'currentMonth',
                customDateFrom: '',
                customDateTo: '',
                selectedAccounts: activeAccountIds,
                selectedCategories: [],
              })
            }}
            sx={{ maxWidth: 150 }}
          >
            {t('statistics.resetFilters') ?? 'Reset'}
          </Button>
        </Stack>
      </Paper>

      {/* Podsumowanie filtrowanych danych */}
      <Paper sx={{ p: 2, bgcolor: '#f9f9f9' }}>
        <Typography variant="body2" color="textSecondary" sx={{ mb: 2 }}>
          üìä {t('statistics.period') ?? 'Period'}: <strong>{filteredStats.periodStart}</strong> -{' '}
          <strong>{filteredStats.periodEnd}</strong>
        </Typography>

        <Grid container spacing={2}>
          <Grid item xs={12} sm={4}>
            <Box sx={{ p: 1 }}>
              <Typography variant="body2" color="textSecondary">
                {t('operations.summary.totalIncome') ?? 'Income'}
              </Typography>
              <Typography variant="h6" sx={{ color: '#4caf50' }}>
                {filteredStats.income.toFixed(2)} z≈Ç
              </Typography>
            </Box>
          </Grid>
          <Grid item xs={12} sm={4}>
            <Box sx={{ p: 1 }}>
              <Typography variant="body2" color="textSecondary">
                {t('operations.summary.totalExpense') ?? 'Expense'}
              </Typography>
              <Typography variant="h6" sx={{ color: '#f44336' }}>
                {filteredStats.expense.toFixed(2)} z≈Ç
              </Typography>
            </Box>
          </Grid>
          <Grid item xs={12} sm={4}>
            <Box sx={{ p: 1 }}>
              <Typography variant="body2" color="textSecondary">
                {t('operations.summary.net') ?? 'Balance'}
              </Typography>
              <Typography variant="h6" sx={{ color: filteredStats.balance >= 0 ? '#4caf50' : '#f44336' }}>
                {filteredStats.balance.toFixed(2)} z≈Ç
              </Typography>
            </Box>
          </Grid>
        </Grid>
      </Paper>

      {/* Por√≥wnanie 3 okres√≥w */}
      {comparisonEnabled && (
        <Grid container spacing={2}>
          {comparisonStats.map(period => (
            <Grid item xs={12} sm={6} md={4} key={period.key}>
              <Paper sx={{ p: 2, bgcolor: '#fafafa' }}>
                <Typography variant="subtitle2" sx={{ fontWeight: 'bold', mb: 1 }}>
                  {period.label}
                </Typography>
                <Stack spacing={1}>
                  <Box sx={{ display: 'flex', justifyContent: 'space-between' }}>
                    <Typography variant="body2" color="textSecondary">
                      {t('operations.summary.totalIncome') ?? 'Income'}:
                    </Typography>
                    <Typography variant="body2" sx={{ color: '#4caf50', fontWeight: 'bold' }}>
                      {period.income.toFixed(2)} z≈Ç
                    </Typography>
                  </Box>
                  <Box sx={{ display: 'flex', justifyContent: 'space-between' }}>
                    <Typography variant="body2" color="textSecondary">
                      {t('operations.summary.totalExpense') ?? 'Expense'}:
                    </Typography>
                    <Typography variant="body2" sx={{ color: '#f44336', fontWeight: 'bold' }}>
                      {period.expense.toFixed(2)} z≈Ç
                    </Typography>
                  </Box>
                  <Box sx={{ display: 'flex', justifyContent: 'space-between', borderTop: '1px solid #ddd', pt: 1 }}>
                    <Typography variant="body2" sx={{ fontWeight: 'bold' }}>
                      {t('operations.summary.net') ?? 'Balance'}:
                    </Typography>
                    <Typography
                      variant="body2"
                      sx={{ color: period.balance >= 0 ? '#4caf50' : '#f44336', fontWeight: 'bold' }}
                    >
                      {period.balance.toFixed(2)} z≈Ç
                    </Typography>
                  </Box>
                </Stack>
              </Paper>
            </Grid>
          ))}
        </Grid>
      )}

      {/* Wykres s≈Çupkowy - Wydatki po kategoriach */}
      {chartData.length > 0 && (
        <Paper sx={{ p: 2 }}>
          <Typography variant="h6" sx={{ mb: 2 }}>
            üí∞ {t('statistics.expensesByCategory') ?? 'Expenses by Category'}
          </Typography>
          <ResponsiveContainer width="100%" height={400}>
            <BarChart data={chartData} margin={{ top: 20, right: 30, left: 20, bottom: 60 }}>
              <CartesianGrid strokeDasharray="3 3" />
              <XAxis
                dataKey="name"
                angle={-45}
                textAnchor="end"
                height={100}
              />
              <YAxis />
              <Tooltip
                formatter={(value: any) => `${value.toFixed(2)} z≈Ç`}
                labelFormatter={() => 'Warto≈õƒá'}
              />
              <Bar dataKey="value" fill="#8884d8" name={t('operations.summary.totalExpense') ?? 'Expense'}>
                {chartData.map((_, index) => (
                  <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />
                ))}
              </Bar>
            </BarChart>
          </ResponsiveContainer>
        </Paper>
      )}

      {chartData.length === 0 && (
        <Paper sx={{ p: 3, textAlign: 'center' }}>
          <Typography color="textSecondary">
            {t('statistics.noData') ?? 'No data to display for selected filters'}
          </Typography>
        </Paper>
      )}
    </Box>
  )
}

export default Statistics
